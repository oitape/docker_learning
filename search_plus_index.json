{"./":{"url":"./","title":"Introduction","keywords":"","body":"Welcome to Docker! By oitm，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2020-10-28 07:48:51 "},"chapter1.html":{"url":"chapter1.html","title":"Docker的世界","keywords":"","body":"什么是docker？ docker是一个命令行程序、一个后台守护进程，以及一组远程服务。它能够简化安装、运行、发布和删除软件。通过使用一项UNIX技术——即容器技术。 容器不是虚拟化的 传统的的程序通常采用硬件虚拟化，以提供隔离。虚拟机提供虚拟的硬件，安装操作系统和其他程序，需要花费很长的时间来创建，且非常消耗资源，不仅要运行我们需要执行的软件，还需要运行整个操作系统的副本。 而docker容器不适用硬件虚拟化。运行在Docker中的程序接口和主机的Linux直接打交道，因为容器中运行的程序和计算机的操作系统之间没有额外的中间层，没有资源冗余软件的运行 docker构建容器隔离包括8个方面 PID命名空间——进程标识符和能力 UTS命名空间——主机名和域名 MNT命名空间——文件系统访问和机构 IPC命名空间——通过共享内存的进程间通信 NET命名空间——网络访问和结构 USR命名空间——用户名和标识 chroot（）——控制文件系统根目录的位置 cgroups——资源保护 简单示例 docker run dockerinaction/hello_world. By oitm，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2019-04-08 11:36:42 "},"rong-qi-zhong-yun-xing-ruan-jian.html":{"url":"rong-qi-zhong-yun-xing-ruan-jian.html","title":"容器中运行软件","keywords":"","body":"在docker容器中拉取并运行程序 By oitm，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2019-04-08 11:36:44 "},"rong-qi-zhong-yun-xing-ruan-jian/213001-ru-hexue-xi-docker-ming-ling.html":{"url":"rong-qi-zhong-yun-xing-ruan-jian/213001-ru-hexue-xi-docker-ming-ling.html","title":"如何学习docker命令","keywords":"","body":"如何学习docker命令 通过 docker help 将显示Docker命令行工具的基本语法，以及所有命令的完整列表。 查看某一个具体命令的功能可通过该如下来显示该命令的作用。 docker help example： docker help version By oitm，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2019-04-08 11:36:44 "},"rong-qi-zhong-yun-xing-ruan-jian/jian-li-yi-ge-wang-zhan-jian-kong-qi.html":{"url":"rong-qi-zhong-yun-xing-ruan-jian/jian-li-yi-ge-wang-zhan-jian-kong-qi.html","title":"建立一个网站监控器","keywords":"","body":" 运行NGINXdocker run --detach --name web nginx:latest 运行此命令，Docker将从Docker Hub上的NGINX仓库下载、安装、运行该镜像软件，运行结束还有一串类似这样的数字 785e0931595766c33ee34e393fdb15955371c60072c218b5b131232487bc1282 这是运行NGINX容器的唯一标识符，标识符显示出来后，并不会发生什么，因为使用了--detach选项，并在后台启动该程序 静默运行在在后台的程序被称作守护程序，当你要在后台运行容器的守护程序，记得使用--detach标志或者它的缩写形式-d 运行邮件程序 docker run -d --name mailer dockerinaction/ch2_mailer 运行交互式容器 docker run --interactive --tty \\ --link web:web \\ --name web_test \\ busybox:latest /bin/sh --interactive：告诉Docker保持标准输入流对容器开放，即使容器没有终端连接。 --tty：告诉Docker为容器分配一个虚拟终端，这将允许你发送信号给容器。 用交互式容器的命令创建一个容器，启动一个UNIX shell，命令被链接到运行NGINX的容器上。 启动监控器docker run -it \\ --name agent \\ --link web:insideweb \\ --link mailer:insidemailer \\ dockerinaction/ch2_agent 会看到终端一直在打印 System up 如果需要后台运行 添加-d选项即可，（注意：暂停agent时【command + c】时，要先执行docker rm agent，再次尝试后台运行agent，你会看到终端不会再有相关log信息） 可通过 docker logs -f agent来实时输出信息。 By oitm，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2019-04-08 11:36:44 "},"rong-qi-zhong-yun-xing-ruan-jian/233001-lie-ju-3001-ting-zhi-3001-zhong-qi-3001-cha-kan-rong-qi-shu-chu.html":{"url":"rong-qi-zhong-yun-xing-ruan-jian/233001-lie-ju-3001-ting-zhi-3001-zhong-qi-3001-cha-kan-rong-qi-shu-chu.html","title":"列举、停止、重启、查看容器输出","keywords":"","body":" 正在运行容器查看 docker ps 类似下面的信息 CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 6328d9ca7c6b dockerinaction/ch2_agent \"/watcher/watcher.sh\" 6 minutes ago Up 5 minutes agent 容器ID 使用的镜像 容器中执行的命令 容器运行时长 容器暴露的网络端口 容器名称 重启容器 docker restart 查看日志 docker logs docker logs 命令有一个选项，--follow 或者 -f ,用来显示整个日志,容器中日志的变化将实时在终端当中呈现。 测试当web服务器停止时会不会发出通知。 docker stop web 等待几秒钟，执行 docker logs mailer 如果看到终端输出 Sending email: To: admin@work Message: The service is down! 说明监控成功检测到Web同期中NGINX服务器已经停止。 By oitm，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2019-04-08 11:36:44 "},"33001-yi-jie-jue-de-wen-ti-he-pid-ming-ming-kong-jian.html":{"url":"33001-yi-jie-jue-de-wen-ti-he-pid-ming-ming-kong-jian.html","title":"PID命名空间","keywords":"","body":"什么是PID 每一个运行的程序或进程，在Linux中都有唯一一个编号，叫做进程标识符即PID。 一个PID命名空间是一组识别进程的数字。Linux提供了工具可以创建多个PID命名空间，每个命名空间拥有一套完整的PID，每个PID命名空间将包含自己的PID1、2、3，以此类推。 运行如下命令可以看到: docker run -d --name namespaceA busybox:latest /bin/sh -c 'sleep 30000' docker run -d --name namespaceB busybox:latest /bin/sh -c 'sleep 30000' 运行 docker exec namespaceA ps PID USER TIME COMMAND 1 root 0:00 sleep 30000 13 root 0:00 ps 运行 docker exec namespaceB ps PID USER TIME COMMAND 1 root 0:00 sleep 30000 6 root 0:00 ps 使用docker exec命令可以在运行的容器中运行额外的进程。ps 命令显示所有正在运行的进程和它们的PID。 如果没有PID命令空间，在一个容器内运行的进程将和其他容器或主机共享相同的ID空间，这样，容器无法确定其他主机有哪些进程在运行。 你可以有选择的创建没有PID命名空间的容器。可以通过 docker create 或 dcoker run中设置 --pid 标志以及将该值设置为 host来进行尝试. 注：常见的冲突问题 两个程序都想要绑定到同一个端口 两个程序都使用相同的临时文件名和文件锁 两个程序想要使用不同版本且全局已经安装的库 同一个程序的两个副本要使用相同的PID文件 第二个安装的程序修改了另一个程序正在使用的环境变量，导致程序的中断 Docker通过Linux的命名空间、根文件系统和虚拟网络组件等工具解决了这些软件冲突。所有这些工具都用来为每个容器提供隔离。 By oitm，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2019-04-08 11:36:42 "},"xiao-chu-yuan-shu-ju-chong-tu.html":{"url":"xiao-chu-yuan-shu-ju-chong-tu.html","title":"消除元数据冲突","keywords":"","body":"构建多个容器运行Web服务器以及针对每个服务器的监视器。 示例：一个客户要求奖励一个系统，为客户承载可变数量的网站，利用前面张杰构建的监控技术。此示例中，将构建多个容器运行web服务器以及针对每个服务器的监视器。 架构图如下所示： By oitm，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2019-04-08 11:36:44 "},"xiao-chu-yuan-shu-ju-chong-tu/ling-huo-de-rong-qi-biao-shi.html":{"url":"xiao-chu-yuan-shu-ju-chong-tu/ling-huo-de-rong-qi-biao-shi.html","title":"灵活的容器标识","keywords":"","body":" 创建多个NGINX容器副本docker run -d --name webid nginx 如果你复制上面命令进行第二次创建，将会失败，并出现冲突错误如下： docker: Error response from daemon: Conflict. The container name \"/webid\" is already in use by container \"1f405a5b8b496ccaca2425924585d2c41fb9646ac886e490a96cf885dbcf83c0\". You have to remove (or rename) that container to be able to reuse that name. See 'docker run --help'. 默认情况下，Docker给配一个为一的名字给他创建的每个容器。--name只是重写了该已知值的进程。如果出现以上冲突可以通过修改名字进行 docker rename webid webid-old 通过docker ps查看第一个运行的名字是否改成功 重命名可以减轻一次命名冲突，但无法避免首要问题。除了名字，Docker分配一个唯一的标识符，是一个十六进制编码的1024位数字，如1f405a5b8b496ccaca2425924585d2c41fb9646ac886e490a96cf885dbcf83c0 ，我们也可以通过该ID执行 stop | exec 命令，即完整的CONTAINER ID。 一般docker生成的ID基本是唯一的，产生冲突几乎不可能，所以大多数Docker界面上你可以看到被截断成12个字符，在获取容器，可以使用他们 docker exec ps docker stop 获取容器ID的方式 - 第一种：简单的启动或创建一个新容器，将命令的结果赋值给一个Shell变量。 - 第二种：如果只想在创建容器使得到容器ID，交互式容器是无法做到的。可以用`docker create`命令。它和`docker run`命令类似，主要区别在于该容器是被停止状态创建的。 如果您是使用shell命令，你可以很方便的将结果分配给一个shell变量，以后可再次使用 CID=$(docker create nignx) echo $CID 将容器ID写入到文件中 docker create --cidfile /tmp/web.cid nginx #执行cat 命令查看 cat /tmp/web.cid 获取最后创建的那个容器的截断ID，可以这么做 docker ps --latest --quiet 缩写形式如下 docker ps -l -q 如果你想获取完整的容器ID，可以带上如下选项 docker ps --no-trunc By oitm，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2019-04-08 11:36:44 "},"xiao-chu-yuan-shu-ju-chong-tu/rong-qi-de-zhuang-tai-he-yi-lai.html":{"url":"xiao-chu-yuan-shu-ju-chong-tu/rong-qi-de-zhuang-tai-he-yi-lai.html","title":"容器的状态和依赖","keywords":"","body":" docker总共有四种状态 运行中 暂停中 重新启动总 已退出 那些被docker create创建的容器从未启动(已退出状态)，想看到所有运行ing 或者 退出的容器，使用该命令查看 docker ps -a 如果你要启动已经停掉的容器可以采用如下命令 docker start docker 的链接内在机理 链接的机制将IP地址注入所依赖的容器，在运行的容器中得到该IP地址。如果你尝试启动一个容器，其依赖于另一个并未运行的容器，docker将不会把该容器的IP地址注入到未运行的容器中。 By oitm，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2019-04-08 11:36:44 "},"xiao-chu-yuan-shu-ju-chong-tu/gou-jian-yu-huan-jing-wu-guan-de-xi-tong.html":{"url":"xiao-chu-yuan-shu-ju-chong-tu/gou-jian-yu-huan-jing-wu-guan-de-xi-tong.html","title":"构建与环境无关的系统","keywords":"","body":" Docker有三个特定的功能，帮助建立与环境无关的系统 只读文件系统 环境变量注入 存储卷 By oitm，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2019-04-08 11:36:44 "},"xiao-chu-yuan-shu-ju-chong-tu/gou-jian-yu-huan-jing-wu-guan-de-xi-tong/zhi-du-wen-jian-xi-tong.html":{"url":"xiao-chu-yuan-shu-ju-chong-tu/gou-jian-yu-huan-jing-wu-guan-de-xi-tong/zhi-du-wen-jian-xi-tong.html","title":"只读文件系统","keywords":"","body":"WrdPress使用MySQL的数据库程序来存储大部分程序，先确保运行WordPress的容器使只读文件系统。 只读文件系统的两个效果 你对容器不能更改他所包含的文件 容器中的攻击者无法破坏文件 docker run -d --name wp --read-only wordpress:4 可以通过检查容器元数据查看容器是否在运行,如果在运行输出为真。 docker inspect --format \"{{.State.Running}}\" wp 会报错，WordPress 有一个MySQL的数据库依赖关系 docker run -d --name wpdb -e MYSQL_ROOT_PASSWORD=ch2demo mysql:5 再次执行如下命令(修改原书命令，增加 -v /tmp/，解决依旧报错问题) docker run -d --name wp2 --read-only -v /run/lock/apache2/ -v /run/apache2/ -v /tmp/ --link wpdb:mysql -p 80 wordpress:4 再通过检查容器元数据发现成功运行中了。 通过使用只读文件系统，以及链接WordPress到另一个运行着数据库的容器，可以确保运行WordPress镜像的容器永远不会改变，如果客户的WP机器除了问题，可在其他地方启动该容器的另一个副本。 目前这样做还是有两个问题 MySQL和WP运行在同一台机器上 WP对重要的设置：数据库名称、管理用户、管理密码数据库加盐等使用默认值。解决这个问题可以创建多个版本WP软件，每个客户特殊配置。 通过环境变量来注入配置则是一个更好的方式。 By oitm，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2019-04-08 11:36:44 "},"xiao-chu-yuan-shu-ju-chong-tu/gou-jian-yu-huan-jing-wu-guan-de-xi-tong/huan-jing-bian-liang-de-zhu-ru.html":{"url":"xiao-chu-yuan-shu-ju-chong-tu/gou-jian-yu-huan-jing-wu-guan-de-xi-tong/huan-jing-bian-liang-de-zhu-ru.html","title":"环境变量的注入","keywords":"","body":"环境变量是通过其执行上下文提供给程序的键值对。它可以让我们在改变一个程序的配置时，无须修改任何文件去启动该程序的命令。 Docker提供这样的机制：将环境变量注入到一个新容器，可在容器创建时就进行配置。 如何查看注入的环境变量，使用下面命令 docker run --env MY_ENVIRONMENT_VAR=\"this is a test\" busybox env --env的缩写形式-e，可用于注入任何环境变量。如果变量已经由镜像或Docker设置，则该值将被覆盖。容器内部运行程序的方式，可依赖这种变量。 最后的env：在同期中执行env命令。 By oitm，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2019-04-08 11:36:44 "},"xiao-chu-yuan-shu-ju-chong-tu/gou-jian-yu-huan-jing-wu-guan-de-xi-tong/jian-li-chi-jiu-hua-de-rong-qi.html":{"url":"xiao-chu-yuan-shu-ju-chong-tu/gou-jian-yu-huan-jing-wu-guan-de-xi-tong/jian-li-chi-jiu-hua-de-rong-qi.html","title":"建立持久化的容器","keywords":"","body":"Docker提供用于监控和重启容器的几个选项： 自动重启容器 使用--restart选项来自动重启容器 docker run -d --name backoff-datector --restart always busybox date Docker并不总是立即重新启动容器，Docker采用了指数回退侧罗定时阐释重新启动，回退策略决定了连续尝试重新启动所需的时间间隔。指数回退策略将会花费在前一次等待连续尝试时间的2倍。 使用init和supervisor进程维持容器的运行状态 init或supervisor进程，用于启动和维护其他程序状态。 容器中的supervisor进程用来保持容器始终运行，即使目标进程出现故障并重启。 下面来创建容器使用supervisord来确保所有相关的进程持续运行 docker run -d -p 80:80 --name lamp-test tutum/lamp 使用docker top命令查看该容器有哪些进程正运行着 docker top lamp-test 你会看到supervisord运行在程序清单中。现在可以通过手动停止容器内的某一进程，来测试supervisord的重启功能。 在容器内杀死进程，需要知道它在容器中的PID值。运行exec自命令来获取 docker exec lamp-test ps 通过指定PID通过kill命令杀死进程 exec lamp-test kill 选择apache2的PID进行替换杀死 当apache2停止时，supervisord进程会记录该事件，并重启该进程。 通过docker logs lamp-test来查看日志 By oitm，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2019-04-08 11:36:44 "},"qing-li.html":{"url":"qing-li.html","title":"清理","keywords":"","body":"Docker中的清理只需要掌握几个简单的命令 使用docker ps命令查看当前正在运行中的程序。 使用docker ps -a查看所有正在运行和停止运行的程序。 使用docker rm 来移除容器。（移除正在运行的容器之前需要先停止） 使用docker stop 来停止正在运行的容器，或者使用docker 人 -f 标志停止一个进程。区别： - 使用-f标志，Docker发送SIG_KILL信号，立即终止接收过程。 - 视同docker stop，将发送SIG_HUG信号。 SIG_HUG的收件人有时间进行最后的退出和清理任务。 SIG_KILL没有这样的允许时间，并可能导致文件损坏。 By oitm，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2019-04-08 11:36:44 "},"ruan-jian-an-zhuang-de-jian-hua.html":{"url":"ruan-jian-an-zhuang-de-jian-hua.html","title":"软件安装的简化","keywords":"","body":"镜像安装细节 Docker Hub和其他注册服务器 使用docker save 和docker load命令加载、导出镜像文件 使用Dockerfiles构建镜像 仓库可容纳多个镜像，每个库中的镜像可由标签来唯一标识。 当使用docker pull 或 docker run命令，如果没有指定一个替代的注册服务器，Docker默认将在Docker Hub里面找。 镜像发布的两种方式 使用命令行来发布独立系统构建镜像，这种方式被认为是不能信任的。 公开Dockerfile，并使用Docker Hub的持续构建系统。可信赖的方式。 使用私有的Docker Hub注册服务器，或将镜像推送到Docker Hub上你的账号中。需要你的认证授权。使用docker login命令登录到Docker'Hub，这样就可以从私有库下载、推送到你控制的任何镜像库。 运行docker login提醒你输入账号密码。完成后使用docker logout命令退出。 查询想要安装的软件 docker search 因为Docker Hub是免费的公共服务，用户会建立大量的个人副本。选择时我们要注意代码是否值得信赖。运行docker search可以看到镜像是从公开的脚本构建的，在AUTOMATED列寻找一个[OK]的标记。 Docker Hub不是软件的唯一来源 其他安装软件的三种方式： 使用替代仓库的注册服务器或运行自己的注册服务器 这种方式需要的视注册服务器的地址，注册服务器后面章节讲解。命令如下 docker pull quay.io/dockerinaction/ch3_hello_registry:latest 格式如下 [REGISTRYHOST/][USERNAME/]NAME[:TAG] 可以手动从文件加载镜像 Docker 提供一个命令将镜像由文件加载到Docker。 首先讲下如何保存一个DockerHub中的镜像到本地文件。 docker pull busybox docker pull 然后执行如下保存命令 docker save -o ~/Desktop/myfile.tar busybox docker save -o myfile.tar 你会看到桌面上存在一个myfile.tar的文件。接着运行移除镜像的命令 docker image rm busybox 或者 docker rmi busybox 移除镜像后，使用docker load将创建的文件再次加载。如果运行docker load命令而不使用 -i 参数，Docker会使用标准输入流，而不是从文件读取归档。 docker load -i ~/Desktop/myfile.tar 然后使用docker images命令你会看到busybox镜像在列表当中。 从其他来源下载项目，并利用提供的Dockerfile自检镜像。 分发Dockerfile类似于分发镜像文件。一般常用Git。git clone https://github.com/dockerinaction/ch3_dockerfile.git 下载完成会看到一个ch3_dockerfile，然后运行如下命令指定ch3_dockerfile路径 `sh docker build -t dia_ch3/dockerfile ch3_dockerfile ``` 然后使用docker images`命令你会看到dia_ch3/dockerfile镜像在列表当中。 安装文件和隔离 镜像层实战 下面会有两个镜像安装的示例，注意安装每个竟像时Docker做了什么。 docker pull dockerinaction/ch3_myapp docker pull dockerinaction/ch3_myotherapp 你会发现运行第一条命令时需要下载等待的时间相对较长，因为它需要openjdk 6镜像。当Docker去安装依赖时，才发现原来该层的依赖关系，且是第一次下载。一旦安装了该层的所有遗爱，该层安装才会结束，openjdk-6会被安装，然后再安装ch3_myapp层。 使用docker images将会看到刚才拉去的两个镜像. 分层关系 镜像维护着父/子依赖关系。在这些依赖关系中，从父层构建形成新的一层。容器中的文件是镜像所创建容器的所有层的合集。镜像可以和任何其他镜像有依赖关系。 By oitm，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2019-04-08 11:36:44 "},"chi-jiu-hua-he-juan-jian-zhuang-tai-gong-xiang.html":{"url":"chi-jiu-hua-he-juan-jian-zhuang-tai-gong-xiang.html","title":"持久化和卷间状态共享","keywords":"","body":"介绍存储卷以及容器之间如何管理数据的方法。 就像在容器中运行一个数据库程序一样，你可以将软件打包在镜像中，当启动容器时，它将初始化空的DB，当其他程序接入该DB时并存入数据，这些数据要如何才能保存下来？暂停一个容器或删除一个容器，这些数据要怎么办？升级数据库程序，如何迁移？ 存储卷简介 一个主机或容器的目录树是由一组挂载点创建而成，这些挂载点描述了如何能构建出一个或多个文件系统。 存储卷提供容器无关的数据管理方式 存储卷是一个数据分割和共享的工具，有一个与容器无关的范围或生命周期。这使得存储卷成为容器化系统设计中关于文件共享或写入最重要的一部分。数据示例根据其范围或者接入容器方式的不同分为以下几种： 数据库软件与数据库中的数据 web应用程序与日志数据 web数据处理应用程序的输入和输出数据 web服务器与静态内容 产品与支持工具 镜像适合打包和分发相对静态的文件，如程序；存储卷则持有动态或专门数据。这种区别使得镜像可重用，数据可简单分享。 更为基本的是：存储卷可以隔离应用程序和主机的关系。镜像被装载到主机，创建出一个容器。Docker不知道主机在哪里运行，只能判断哪些文件在容器中可用。也就是Docker本身就没有办法利用主机上的设施，如装载的网络存储、混合光纤、固态硬盘。但有主机知识的用户可以使用存储卷，在容器中将这些目录映射到主机的存储上。 NoSQL数据库使用存储卷 Apache Cassandra项目提供了一个具有内置集群，最终一致性和线性写入可伸缩的列数据库。下面使用官方的Cassandra镜像创建一个节点集群，并创建一个键空间，删除容器，然后再另一个容器中恢复这个新节点的键空间。 创建已定义存储卷的单个容器，这也被称为存储卷容器（高级模式） docker run -d --volume /var/lib/cassandra/data --name cass-shared alpine echo Data Container 存储卷容器将立即停止。不要删除他。会在后面创建运行Cassandra新容器时，使用这个存储卷： docker run -d --volumes-from cass-shared --name cass1 cassandra:2.2 Docker下载完镜像，创建一个新容器，并复制存储卷容器的卷定义。然后容器的存储卷挂载在/var/lib/cassandra/data。指向主机目录树相同的位置。接下来，从cassandra:2.2镜像启动容器，运行Cassandra客户端工具，并连接到正在运行的服务器： docker run -it --rm --link cass1:cass cassandra:2.2 cqlsh cass 接下来就可以从CQLSH命令行检查或修改Cassandra数据库。首先查找一个docker_hello_world的键空间 select * from system.schema_keyspaces where keyspace_name = 'docker_hello_world'; Cassandra应该返回的是(0 rows)的空列表，下面使用命令进行创建 create keyspace docker_hello_world with replication = { 'class':'SimpleStrategy', 'replication_factor':1 }; 然后再执行上面的查询会看到插入的结果。使用quit命令退出CQLSH程序并停止容器 容器在创建时，使用了--rm标志，在命令停止会被自动删除。通过停止和删除所创建的Cassandra节点 docker stop cass1 docker rm -vf cass1 执行完成后，Cassandra客户端和服务器都将被删除。如果刚才所做的修改需要持久化，唯一办法就是存储卷容器。 可以重复上面的步骤进行测试，下图描述了整个系统。 下面使用三个命令将测试数据恢复 docker run -d --volumes-from cass-shared --name cass2 cassandra:2.2 docker run -it --rm --link cass2:cass cassandra:2.2 cqlsh cass select * from system.schema_keyspaces where keyspace_name = 'docker_hello_world'; 会发现有一条数据 存储卷类型 存储卷有两种类型，每一个存储卷就是容器目录树的挂载点在主机目录树中的位置，但不同的存储卷类型在主机的位置是不同的。 绑定挂载存储卷：使用用户提供的主机目录或文件 管理存储卷：使用由Docker守护进程控制的位置，被称为Docker管理空间，如下图 绑定挂载卷 绑定挂载存储卷 在主机提供的文件或目录需要挂载到容器目录的特定位置时，很有用 将数据分享给运行在容器外的进程，比如主机系统组件 将主机数据通过已知的主机目录分享给容器中运行的程序 下面使用DOcker启动web服务器，并绑定挂载你的文档地址在web服务器新容器的文档根目录上。在主机用户根目录执行以下命令 mkdir example-docs cd example-docs touch index.html echo hello world > index.html 然后启动web应用程序 docker run -d --name bmweb -v ~/example-docs:/usr/local/apache2/htdocs -p 8090:80 httpd:latest 使用-v选项和位置映射来创建绑定挂载卷。该映射以冒号分割。冒号左边是：主机文件系统上的绝对路径，冒号右边是：容器中挂载的目标存储位置。必须使用绝对路径指定该位置。 你在主机上访问http://localhost:8090/ 会出现hello world 如果你想确保在Apache HTTP web服务器不能更改此卷内容，可以通过在存储卷映射规则后追加：ro来完成。 docker rm -vf bmweb docker run -d --name bmweb_ro -v ~/example-docs:/usr/local/apache2/htdocs/:ro -p 8090:80 httpd:latest 通过挂载只读，可避免容器内的任何进程修改该卷内容 注意：如果你指定了一个不存在的主机目录，Docker会为你创建相应的目录。 绑定挂在卷并不仅限于目录，还可以绑定挂在卷装入单个文件。在创建或链接资源时，避免与其他资源的冲突，提供灵活性。 当你要安装一个特定的文件到一个包含其他文件的目录。如果你用整个目录绑定挂载到该位置，那么其他文件都将丢失，通过使用一个特定文件作为存储卷，可以只覆盖或插入单个文件。 注意：文件必须在创建容器之前就存在于主机上，否则Docker将自动创建一个目录，把它挂在在需要的文职 Docker管理卷 Docker管理卷不同于绑定挂载卷，因为Docker守护程序会在主机文件系统中创建存储卷，并有Docker管理。 使用管理卷是一种在文件系统特定位置解耦卷的方法。当你执行 docker run 使用-v选项，只要指定容器目录树中的挂载点，管理卷即可创建。在前面的Cassandra示例已经创建了管理卷 // 容器中指定存储卷的挂载点 docker run -d --volume /var/lib/cassandra/data --name cass-shared alpine echo Data Container 当你创建这个容器时，Docker守护程序在主机文件系统中创建了目录。来存储这三个存储卷的内容。可以使用docker inspect命令过滤这存储卷来找到这个目录的确切位置。 docker inspect cass-shared | grep Mounts -A 10 -A 10代表找到Mounts后面的10行内容也显示出来 你会看到Source和Destination的位置 通过使用Docker管理卷，你只要简单的指出“我需要一个地方存放一些我工作的数据” 共享存储卷 容器之间存储卷的共享 主机依赖的共享 多个容器主机依赖的共享：每个容器在主机文件系统的已知位置有一个绑定挂载卷。 下面创建两个容器，一个名为plath的容器写文件，一个容器则读该文件。这两个容器都有一个共同的绑定挂挂载卷。 mkdir web-logs-example docker run --name plath -d -v ~/web-logs-example:/data dockerinaction/ch4_writer_a docker run --rm -v ~/web-logs-example:/reader-data alpine:latest head /reader-data/logA 共享和columes-from 标志 docker run命令提供一个标志，可将卷从一个或多个容器复制到新的容器中。标志 --volumes 可设定多次，可指定多个源容器。 --volumes-from标志：复制任何本卷所引用的元容器到新的容器中。该标志也有传递性，可以直接或者传递的复制卷。 注意：复制卷始终具有相同的挂载点。 管理卷的生命周期 管理卷的生命周期独立于任何容器，你只能通过容器来引用它们。 管理卷的权限 管理卷是二等实体，没有办法分享或删除特定的管理卷，因为没有办法指定一个管理卷。 如果你不适用绑定挂载卷，只创建了管理卷，那么只能通过它们的容器来区分。 区分存储卷最好的方法是为每一个管理卷定义一个容器。这样有利于删除特定的存储卷。否则需要在容器中检查卷的映射，并手动清理Docker管理空间。删除卷需要被引用的容器，重要的是了解哪些容器拥有这个管理卷。 存储卷的清理 清理管理卷是一个手动的任务，可以防止意外损坏潜在的有价值的数据。Docker守护程序无法删除绑定挂载卷，因为源卷不在Dokcer管理范围内。 删除容器时，Docker可以删除管理卷。运行带有-v选项的docker rm命令试图删除除目标容器中引用的任何管理卷。由其他容器引用的管理卷江北忽略，但内部引用计数仍然会递减。 如果删除一个已引用管理卷的容器，但没有使用-v标志，就会产生孤立卷。移除孤立卷需要一些列手工操作。所以我们移除容器时最好ca用加上-v标志，防止孤立卷 docker rm -v container 还可以使用如下命令删除所有停止的容器和卷： docker rm -v ${docker ps -aq} 存储卷的高级容器模式 卷容器模式 卷容器模式：是一个容器，只提供卷的句柄。如果你遇到一个用于与多个容器共享一组卷的情况，或者需要对一组适合常见用例的存储卷进行分类，那么这将很有用。 卷容器不需要运行，因为停止时容器仍能保证存储卷的引用。 数据打包的存储卷容器 数据打包的卷容器将镜像中的静态内容复制到其定义的存储卷。这些容器可用于分发关键架构信息，如配置、密钥材料和代码。 多态容器模式 多台工具就是以一致性的方式进行交互，但可能有几个实现，分别做不同的事情。使用存储卷你可以注入不同行为到容器中，而无需修改其镜像， By oitm，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2019-04-08 11:36:42 "},"wang-luo-fang-wen.html":{"url":"wang-luo-fang-wen.html","title":"网络访问","keywords":"","body":"网络访问 这章学习以下内容，关注于单主机网络 在Docker中如何将容器连接到网络 创建暴露在网络上运行的容器 一个容器使用另外一个容器的网络软件 容器时如何与主机还有主机网络进行交互的。 Docker的网络 Docker关系两种类型网络：单主机虚拟网络和多主机虚拟网络。本地虚拟网络用来提供容器隔离。多主机虚拟网络构建了一个抽象的覆盖网络，在这个网络中，任何容器相对于网络上的其他容器都拥有独立的、可路由的IP地址。 本地Docker网络拓扑结构 Docker使用操作系统的底层特性构建了一个特殊的、可定制的虚拟网络拓扑结构。这个虚拟网络只在安装有Docker的机器上有效，并且它由主机上的机器和主机所连接的网络之间的路由构成。 每个容器各自拥有一个本地回环接口和一个分离的以太网接口，其中以太网接口连接着在主机命名空间上的另一个虚拟接口。这两个互联的接口在主机网络栈和每个容器的网络栈之间建立了连接。每个容器都被赋予了一个唯一的私有IP地址，从外部的网络不能直接连接到该私有IP。网络连接需要经过Docker网桥接口路由到另一网络，这个网桥接口被称为docker 0，可以吧docker 0想象成路由器，为每个容器创建的虚拟接口都会连接到docker 0，这样他们就构成一个网络。最后这个网桥接口docker 0会连接到主机所连接的网络。 使用docker命令行工具，可以自定义IP地址、网桥接口docker 0所连接的主机接口、容器之间通信的方式。Docker使用内核命名空间来创建这些私有的虚拟接口，但是命名空间本身不提供网络的隔离。网络暴露或者隔离是通过煮鸡蛋防护墙规则来实现。 Docker命令行选项提供四种网络容器原型 所有的Docker容器都要符合这四种原型中的一种，原型定义了一个容器如何与其他的本地容器、主机网络进行通讯。每一种原型有不同的目的，你可以认为他们拥有不同程度的隔离。 Closed容器 Joined容器 Bridged容器 Open容器 下图最强大意味着隔离程度最高 Closed容器 这种容器不允许任何网络流量，运行这种容器只能访问本地回环接口。如果进程只需要和本省或者其他本地进程通信的话，采用这种容器。 所有Docker容器都有权限访问一个私有的本地回环接口，Docker为每一个容器创建私有本地回环接口，目的是让运行在容器中的程序能够通过网络进行通信，且这些通信不能离开容器。 通过添加--net none参数创建closed容器 //创建 并列出所有的接口 docker run --rm --net none alpine ip addr 可看到本地回环接口是唯一可用的网络接口，并且绑定在127.0.0.1上 我们还可以进行测试看Close容器是否能访问到外部网络，尝试访问谷歌DNS服务器 docker run --rm --net none alpine ping -w 2 8.8.8.8 可以发现输出结果ping: sendto: Network unreachable Bridged容器 Bridged容器放开了网络的隔离程度，可定制性最高。Bridged容器拥有两个接口，一个是私有的本地回环接口，另一个是私有接口通过网桥连接到主机的其他容器。 Bridged容器时最常见的网络容器原型。 访问外部网络 选择Bridged容器通常是进程需要访问外部网络，使用docker run命令中的 --net选项，可以忽略，或者将--net的值设置为bridge. docker run --rm --net bridge alpine ip addr 尝试下访问外部网络docker run --rm alpine ping -w 2 8.8.8.8 你会看到容器执行了2秒的ping测试并输出了相关ping的信息 自定义命名解析 域名系统DNS是将主机名映射成IP地址的协议。网桥网络上的容器和其他在该网络上的计算机，拥有不具备公共路由能力的IP地址是非常典型的。除非你运行有自己的DNS服务器，否则你不能通过名字来映射他们。 Docker提供了不同的选项来自定义DNS配置。 docker run命令有一个--hostname选项，你可以使用这个选项来设置一个新容器的主机名。这个选项会在该容器的DNS覆盖系统中添加一条记录。这条记录会将提供的主机名映射成该容器的桥接IP地址。 //nslookup barker 将主机名解析成IP地址 docker run --rm --hostname barker alpine nslookup barker 最后一行的IP地址就是新创建的容器的桥接IP地址。为容器设置主机名是很有用的，比如容器中程序要查询它自己的IP地址或者必须自我识别时，因为其他容器不知道这个主机名，所以它的功能是有限的。但你使用一个外部DNS服务器，你就能共享这些主机名。 第二个自定义DNS配置的选项能够指定一个或者多个DNS服务器。 docker run --rm --dns 8.8.8.8 alpine nslookup docker.com 创建容器，并将它的DNS服务器设置为Google的公开DNS服务器，解析docker.com 的IP地址。 如果你在笔记本上运行Docker，并且经常在在不同的网路供应商之间移动，那么使用一个特定的DNS服务武器能够提供一直性。对构建服务和网络这是一个非常重要的工具。 设置DNS服务器需要注意 值必须是IP地址 --dns=[]选项可以被使用多次来设置多个DNS服务器 --dns=[]选项可以在你启动后台进程Docker daemon时进行设置。这么做这些DNS服务器会默认配置到每一个容器上。 第三个DNS相关的选项--dns-search，允许指定一个DNS查找域，当设置该选项后（不包括已知顶级域名.com .cn等），在查询时，任何不包括已知域名的主机名都会自动加上该后缀名。docker run --rm --dns-search docker.com busybox nslookup registry.hub 开放对容器的访问 Bridged容器默认情况下不能被主机网络访问。容器被主机的防火墙保护了起来。 docker run命令提供了一个-p --publish=[]选项，它能够在主机网络栈上的端口和容器端口之间创建映射关系。映射的格式有以下四种 跨容器通信 所有Bridged容器都是在同一个桥接网络上，并且默认能够互相通信。如下图所示 启动后台进程时，你可以选择关闭容器之间的网络连接。使用--icc=false选项来达到这个效果。 修改网桥接口的配置 Docker提供了三个选项来自定义网桥接口，这个接口在Docker daemon首次启动时就创建了。这些选项能够让使用者做一下事情。 定义网桥的地址和子网 定义容器所能获取的IP地址的范围 定义最大传输单元 MTU 定义IP地址和子网范围，可在Docker启动后台进程时使用--bip（bridge IP）选项。假设你想将网桥的IP地址设置为192.168.0.128，并且只想分配这个子网最后的128个地址，这时你可将--bip选项值设置为192.168.0.128/25 根据协议，以太网接口拥有1500字节的最大数据包大小，特殊情况下你需要修改默认的最大传输单元，可以使用--mtu来设置这个大小docker -d --mtu 1200 Joined容器 容器之间没有任何隔离。这种类型的原型通过将某一个容器接口的访问权提供给另外一个新的容器来构建。这种情况下，接口就类似于共享的数据卷。 使用joined容器的情况 不同容器上的程序通过本地回环接口进行通信时 当一个容器中的程序将要改变Joined网络栈，而另外一个程序将要使用那个被改变的网络栈时，请使用Joined容器。 当你想要监控另外一个容器中某个程序的网络流量时 Open容器 Open容器非常大危险，他没有网络容器，并且对主机网络有完全的访问权。包括对重要主机服务的访问权。 当docker run命令指定--net选项的值为host时，就会创建open容器 docker run --rm --net host alpine ip addr 运行以上命令会从最新的alpine镜像创建一个容器，并没有任何的网络隔离。当这个容器执行 ip addr命令时，你可以看到所有主机上的网络接口，包括docker 0. 跨容器依赖 如何在一个容器中使用另外一个容器的网络软件？考虑下网桥网络在容器创建时动态赋予它IP地址，如何做到本地服务发现？ 解决这个问题可以使用一个本地的DNS服务器，并且容器启动时在DNS服务器中进行注册。 链接——本地服务发现 创建新的容器，可以将它和另外一个容器相链接。新容器创建时目标容器必须正在运行。 为新容器添加一条链接会发生以下三件事： 描述目标容器的环境变量会被创建 链接的别名和对应的目标容器的IP地址会被添加到DNS覆盖列表中 跨容器通信被禁止了，Docker会添加特定的防火墙规则来允许被链接的容器间通信 链接别名 链接是单向的网络依赖，当一个容器被创建且指定了链接对象时，该依赖被创建。--link选项接受一个参数来实现这个目的。这个参数是容器名字或ID到别名的映射。别名只要求在被创建容器范围内是唯一的。因此，如果三个名为a、b、c的容器已经存在并且正在运行，可以使用以下命令docker run --link a:alias-a --link b:alias-b --link c:alias-c 链接的本质和缺点 链接的本质就是静态的、具有方向性和无传递性的依赖。无传递性就是被链接的容器不会继承链接。 链接通过检测目的容器的网络信息，然后将这些信息注入新容器中。由于这个操作过程是在容器创建期间进行的，并且在一个容器运行之间，Docker不知道该容器的IP地址，因此链接只能在新容器到已存在的容器之间构建。 By oitm，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2019-04-08 11:36:44 "},"ge-li.html":{"url":"ge-li.html","title":"隔离","keywords":"","body":"内存限制 在docker run命令上使用-m或--memory选项来设置内存限制，这个选项会接受一个值和一个基础单元作为参数。格式where unit = b,k,m or g在这个命令中: b-字节、k-千字节、m-兆字节、g-千兆字节。 docker run -d --name ch6_mariadb --memory 256m --cpu-shares 1024 --user nobody --cap-drop all dockerfile/mariadb 清理正在运行的容器 // -v 选项清理数据卷 f选项：如果容器正在运行 会停止他们 docker rm -vf ${container} IPC命名空间 By oitm，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2019-04-08 17:20:23 "},"er-3001-jing-xiang-fa-bu-da-bao-ruan-jian/zai-jing-xiang-zhong-da-bao-ruan-jian.html":{"url":"er-3001-jing-xiang-fa-bu-da-bao-ruan-jian/zai-jing-xiang-zhong-da-bao-ruan-jian.html","title":"在镜像中打包软件","keywords":"","body":"从容器构建镜像 打包一个HelloWorld 从一个容器构建一个镜像包含三部分： 需要从一个已存在的镜像创建一个容器 修改这个容器的文件系统，这些改动会被保存在容器的联合文件系统(UFS)的新文件层 需要对改动进行提交，这样就能从新镜像创建新的容器 利用下面的简单示例创建一个hw_image的新镜像。 修改容器中的文件 docker run --name hw_container ubuntu:latest touch /HelloWorld 将改动提交到新镜像中 docker commit hw_container hw_image \\#取出被改动的文件 docker rm -vf hw_container 检测容器中的文件 docker run --rm hw_image ls -l /HelloWorld 打包Git 将Git安装到Ubuntu镜像中 从一个基础镜像创建一个容器 docker run -it --name image-dev ubuntu:latest /bin/bash 上面的命令会启动一个运行bash shell的新容器。 在容器内部执行安装git命令 apt-get update apt-get -y install git 如果顺利的话就安装成功了，使用git version来查看安装的版本 By oitm，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2019-07-01 18:01:19 "},"zhi-shi-dian/docker.html":{"url":"zhi-shi-dian/docker.html","title":"Docker环境","keywords":"","body":" 配置docker环境 CentOS7 内核3.1以上版本 uname -r 移除旧版本yum remove docker docker-common docker-selinux docker-engine yum remove docker-ce rm -rf /var/lib/docker 安装依赖包 yum install -y yum-utils device-mapper-persistent-data lvm2 #安装前可查看device-mapper-persistent-data和lvm2是否已经安装 rpm -qa|grep device-mapper-persistent-data rpm -qa|grep lvm2 设置yum源yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo 跟新yum软件包索引yum makecache fast 安装yum install docker-ce -y #安装指定版本docker-ce可使用以下命令查看 yum list docker-ce.x86_64 --showduplicates | sort -r # 安装完成之后可以使用命令查看 docker version 配置镜像加速 1.注册登录开通阿里云容器镜像服务 2.查看控制台，招到镜像加速器并复制自己的加速器地址 3.找到/etc/docker目录下的daemon.json文件，没有则直接vi daemon.json#填写自己的加速器地址 { \"registry-mirrors\": [\"https://zfzbet67.mirror.aliyuncs.com\"] } 通知systemd重载此配置文件systemctl daemon-reload 启动docker服务systemctl restart docker 启动一个mysql docker pull mysql:5.7 #创建三个要挂载的目录 mkdir -p /my/mysql/conf mkdir -p /my/mysql/data mkdir -p /my/mysql/logs #复制文件 并修改字符 docker cp mysql:/etc/mysql/mysql.conf.d/mysqld.cnf /my/mysql/conf/ vi /my/mysql/conf/mysqld.conf character-set-server=utf8 #最终启动命令 docker run \\ --name mysql \\ -p 3306:3306 \\ -v /my/mysql/conf:/etc/mysql/mysql.conf.d/ \\ -v /my/mysql/data:/var/lib/mysql \\ -v /my/mysql/logs:/logs \\ -e MYSQL_ROOT_PASSWORD=root \\ -d mysql:5.7 By oitm，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2020-10-28 08:25:58 "},"zhi-shi-dian/dockerchang-yong-cao-zuo.html":{"url":"zhi-shi-dian/dockerchang-yong-cao-zuo.html","title":"Docker常用操作","keywords":"","body":" docker常用命令 table th:nth-of-type(1) { width: 130px; } table th:nth-of-type(2) { width: 200px; } | 作用 | 命令 | | :- | :- | | 搜索 | docker search ${key} | | 拉取镜像 | docker pull 镜像名:TAG Tag表示版本，有些镜像的版本显示latest，为最新版本| |查看所有镜像| docker images ls| |删除镜像|docker rmi -f 镜像ID或者镜像名:TAG -f 表示强制删除| |获取源信息|docker inspect 镜像ID或者镜像名:TAG| |运行|docker run --name 容器名 -i -t -p 主机端口:容器端口 -d -v 主机目录:容器目录:ro 镜像ID或镜像名:TAG --name 指定容器名，可自定义，不指定自动命名 -i 以交互模式运行容器 -t 分配一个伪终端，即命令行，通常-it组合来使用 -p 指定映射端口，讲主机端口映射到容器内的端口-d 后台运行容器 -v 指定挂载主机目录到容器目录，默认为rw读写模式，ro表示只读 | |容器列表|docker ps -a -q -a 查看所有容器(运行中、未运行) -q 只查看容器的ID| |容器操作|docker start 容器ID或容器名docker stop 容器ID或容器名 docker rm -f 容器ID或容器名| |容器日志|docker logs 容器ID或容器名| |进入容器|docker exec -it 容器ID或者容器名 /bin/bash| |copy文件|docker cp 主机文件路径 容器ID或容器名:容器路径 #主机中文件拷贝到容器中 docker cp 容器ID或容器名:容器路径 主机文件路径 #容器中文件拷贝到主机中| |容器元信息|docker inspect 容器ID或容器名| By oitm，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2020-10-28 08:25:58 "}}